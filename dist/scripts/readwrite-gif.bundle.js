(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{226:function(module,exports,__webpack_require__){eval('/**\n * This class lets you encode animated GIF files\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nvar LZWEncoder = __webpack_require__(227),\n  NeuQuant = __webpack_require__(228);\n\nvar GIFEncoder = function() {\n\n  for (var i = 0, chr = {}; i < 256; i++)\n    chr[i] = String.fromCharCode(i);\n\n  function ByteArray() {\n    this.bin = [];\n  }\n\n  ByteArray.prototype.getData = function() {\n    for (var v = \'\', l = this.bin.length, i = 0; i < l; i++)\n      v += chr[this.bin[i]];\n    return v;\n  };\n\n  ByteArray.prototype.writeByte = function(val) {\n    this.bin.push(val);\n  };\n\n  ByteArray.prototype.writeUTFBytes = function(string) {\n    for (var l = string.length, i = 0; i < l; i++)\n      this.writeByte(string.charCodeAt(i));\n  };\n\n  ByteArray.prototype.writeBytes = function(array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++)\n      this.writeByte(array[i]);\n  };\n\n  var exports = {};\n  var width; // image size\n  var height;\n  var transparent = null; // transparent color if given\n  var transIndex; // transparent index in color table\n  var repeat = -1; // no repeat\n  var delay = 0; // frame delay (hundredths)\n  var started = false; // ready to output frames\n  var out;\n  var image; // current frame\n  var pixels; // BGR byte array from frame\n  var indexedPixels; // converted frame indexed to palette\n  var colorDepth; // number of bit planes\n  var colorTab; // RGB palette\n  var usedEntry = []; // active palette entries\n  var palSize = 7; // color table size (bits-1)\n  var dispose = -1; // disposal code (-1 = use default)\n  var closeStream = false; // close stream when finished\n  var firstFrame = true;\n  var sizeSet = false; // if false, get size from first frame\n  var sample = 10; // default sample interval for quantizer\n  var comment = "Generated by jsgif (https://github.com/antimatter15/jsgif/)"; // default comment for generated gif\n\n  /**\n   * Sets the delay time between each frame, or changes it for subsequent frames\n   * (applies to last frame added)\n   * int delay time in milliseconds\n   * @param ms\n   */\n\n  var setDelay = exports.setDelay = function setDelay(ms) {\n    delay = Math.round(ms / 10);\n  };\n\n  /**\n   * Sets the GIF frame disposal code for the last added frame and any\n   *\n   * subsequent frames. Default is 0 if no transparent color has been set,\n   * otherwise 2.\n   * @param code\n   * int disposal code.\n   */\n\n  var setDispose = exports.setDispose = function setDispose(code) {\n    if (code >= 0) dispose = code;\n  };\n\n  /**\n   * Sets the number of times the set of GIF frames should be played. Default is\n   * 1; 0 means play indefinitely. Must be invoked before the first image is\n   * added.\n   *\n   * @param iter\n   * int number of iterations.\n   * @return\n   */\n\n  var setRepeat = exports.setRepeat = function setRepeat(iter) {\n    if (iter >= 0) repeat = iter;\n  };\n\n  /**\n   * Sets the transparent color for the last added frame and any subsequent\n   * frames. Since all colors are subject to modification in the quantization\n   * process, the color in the final palette for each frame closest to the given\n   * color becomes the transparent color for that frame. May be set to null to\n   * indicate no transparent color.\n   * @param\n   * Color to be treated as transparent on display.\n   */\n\n  var setTransparent = exports.setTransparent = function setTransparent(c) {\n    transparent = c;\n  };\n\n\n  /**\n   * Sets the comment for the block comment\n   * @param\n   * string to be insterted as comment\n   */\n\n  var setComment = exports.setComment = function setComment(c) {\n    comment = c;\n  };\n\n\n\n  /**\n   * The addFrame method takes an incoming BitmapData object to create each frames\n   * @param\n   * BitmapData object to be treated as a GIF\'s frame\n   */\n\n  var addFrame = exports.addFrame = function addFrame(im, is_imageData) {\n\n    if ((im === null) || !started || out === null) {\n      throw new Error("Please call start method before calling addFrame");\n    }\n\n    var ok = true;\n\n    try {\n      if (!is_imageData) {\n        image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\n        if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\n      } else {\n        image = im;\n      }\n      getImagePixels(); // convert to correct format if necessary\n      analyzePixels(); // build color table & map pixels\n\n      if (firstFrame) {\n        writeLSD(); // logical screen descriptior\n        writePalette(); // global color table\n        if (repeat >= 0) {\n          // use NS app extension to indicate reps\n          writeNetscapeExt();\n        }\n      }\n\n      writeGraphicCtrlExt(); // write graphic control extension\n      if (comment !== \'\') {\n        writeCommentExt(); // write comment extension\n      }\n      writeImageDesc(); // image descriptor\n      if (!firstFrame) writePalette(); // local color table\n      writePixels(); // encode and write pixel data\n      firstFrame = false;\n    } catch (e) {\n      ok = false;\n    }\n\n    return ok;\n  };\n\n  /**\n   * Adds final trailer to the GIF stream, if you don\'t call the finish method\n   * the GIF stream will not be valid.\n   */\n\n  var finish = exports.finish = function finish() {\n\n    if (!started) return false;\n\n    var ok = true;\n    started = false;\n\n    try {\n      out.writeByte(0x3b); // gif trailer\n    } catch (e) {\n      ok = false;\n    }\n\n    return ok;\n  };\n\n  /**\n   * Resets some members so that a new stream can be started.\n   * This method is actually called by the start method\n   */\n\n  var reset = function reset() {\n\n    // reset for subsequent use\n    transIndex = 0;\n    image = null;\n    pixels = null;\n    indexedPixels = null;\n    colorTab = null;\n    closeStream = false;\n    firstFrame = true;\n  };\n\n  /**\n   * * Sets frame rate in frames per second. Equivalent to\n   * <code>setDelay(1000/fps)</code>.\n   * @param fps\n   * float frame rate (frames per second)\n   */\n\n  var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\n    if (fps != 0xf) delay = Math.round(100 / fps);\n  };\n\n  /**\n   * Sets quality of color quantization (conversion of images to the maximum 256\n   * colors allowed by the GIF specification). Lower values (minimum = 1)\n   * produce better colors, but slow processing significantly. 10 is the\n   * default, and produces good color mapping at reasonable speeds. Values\n   * greater than 20 do not yield significant improvements in speed.\n   * @param quality\n   * int greater than 0.\n   * @return\n   */\n\n  var setQuality = exports.setQuality = function setQuality(quality) {\n    if (quality < 1) quality = 1;\n    sample = quality;\n  };\n\n  /**\n   * Sets the GIF frame size. The default size is the size of the first frame\n   * added if this method is not invoked.\n   * @param w\n   * int frame width.\n   * @param h\n   * int frame width.\n   */\n\n  var setSize = exports.setSize = function setSize(w, h) {\n\n    if (started && !firstFrame) return;\n    width = w;\n    height = h;\n    if (width < 1) width = 320;\n    if (height < 1) height = 240;\n    sizeSet = true;\n  };\n\n  /**\n   * Initiates GIF file creation on the given stream.\n   * @param os\n   * OutputStream on which GIF images are written.\n   * @return false if initial write failed.\n   */\n\n  var start = exports.start = function start() {\n\n    reset();\n    var ok = true;\n    closeStream = false;\n    out = new ByteArray();\n    try {\n      out.writeUTFBytes("GIF89a"); // header\n    } catch (e) {\n      ok = false;\n    }\n\n    return started = ok;\n  };\n\n  var cont = exports.cont = function cont() {\n\n    reset();\n    var ok = true;\n    closeStream = false;\n    out = new ByteArray();\n\n    return started = ok;\n  };\n\n  /**\n   * Analyzes image colors and creates color map.\n   */\n\n  var analyzePixels = function analyzePixels() {\n\n    var len = pixels.length;\n    var nPix = len / 3;\n    indexedPixels = [];\n    var nq = new NeuQuant(pixels, len, sample);\n\n    // initialize quantizer\n    colorTab = nq.process(); // create reduced palette\n\n    // map image pixels to new palette\n    var k = 0;\n    for (var j = 0; j < nPix; j++) {\n      var index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\n      usedEntry[index] = true;\n      indexedPixels[j] = index;\n    }\n\n    pixels = null;\n    colorDepth = 8;\n    palSize = 7;\n\n    // get closest match to transparent color if specified\n    if (transparent !== null) {\n      transIndex = findClosest(transparent);\n    }\n  };\n\n  /**\n   * Returns index of palette color closest to c\n   */\n\n  var findClosest = function findClosest(c) {\n\n    if (colorTab === null) return -1;\n    var r = (c & 0xFF0000) >> 16;\n    var g = (c & 0x00FF00) >> 8;\n    var b = (c & 0x0000FF);\n    var minpos = 0;\n    var dmin = 256 * 256 * 256;\n    var len = colorTab.length;\n\n    for (var i = 0; i < len;) {\n      var dr = r - (colorTab[i++] & 0xff);\n      var dg = g - (colorTab[i++] & 0xff);\n      var db = b - (colorTab[i] & 0xff);\n      var d = dr * dr + dg * dg + db * db;\n      var index = i / 3;\n      if (usedEntry[index] && (d < dmin)) {\n        dmin = d;\n        minpos = index;\n      }\n      i++;\n    }\n    return minpos;\n  };\n\n  /**\n   * Extracts image pixels into byte array "pixels\n   */\n\n  var getImagePixels = function getImagePixels() {\n    var w = width;\n    var h = height;\n    pixels = [];\n    var data = image;\n    var count = 0;\n\n    for (var i = 0; i < h; i++) {\n\n      for (var j = 0; j < w; j++) {\n\n        var b = (i * w * 4) + j * 4;\n        pixels[count++] = data[b];\n        pixels[count++] = data[b + 1];\n        pixels[count++] = data[b + 2];\n\n      }\n\n    }\n  };\n\n  /**\n   * Writes Graphic Control Extension\n   */\n\n  var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\n    out.writeByte(0x21); // extension introducer\n    out.writeByte(0xf9); // GCE label\n    out.writeByte(4); // data block size\n    var transp;\n    var disp;\n    if (transparent === null) {\n      transp = 0;\n      disp = 0; // dispose = no action\n    } else {\n      transp = 1;\n      disp = 2; // force clear if using transparent color\n    }\n    if (dispose >= 0) {\n      disp = dispose & 7; // user override\n    }\n    disp <<= 2;\n    // packed fields\n    out.writeByte(0 | // 1:3 reserved\n        disp | // 4:6 disposal\n        0 | // 7 user input - 0 = none\n        transp); // 8 transparency flag\n\n    WriteShort(delay); // delay x 1/100 sec\n    out.writeByte(transIndex); // transparent color index\n    out.writeByte(0); // block terminator\n  };\n\n  /**\n   * Writes Comment Extention\n   */\n\n  var writeCommentExt = function writeCommentExt() {\n    out.writeByte(0x21); // extension introducer\n    out.writeByte(0xfe); // comment label\n    out.writeByte(comment.length); // Block Size (s)\n    out.writeUTFBytes(comment);\n    out.writeByte(0); // block terminator\n  };\n\n\n  /**\n   * Writes Image Descriptor\n   */\n\n  var writeImageDesc = function writeImageDesc() {\n\n    out.writeByte(0x2c); // image separator\n    WriteShort(0); // image position x,y = 0,0\n    WriteShort(0);\n    WriteShort(width); // image size\n    WriteShort(height);\n\n    // packed fields\n    if (firstFrame) {\n      // no LCT - GCT is used for first (or only) frame\n      out.writeByte(0);\n    } else {\n      // specify normal LCT\n      out.writeByte(0x80 | // 1 local color table 1=yes\n          0 | // 2 interlace - 0=no\n          0 | // 3 sorted - 0=no\n          0 | // 4-5 reserved\n          palSize); // 6-8 size of color table\n    }\n  };\n\n  /**\n   * Writes Logical Screen Descriptor\n   */\n\n  var writeLSD = function writeLSD() {\n\n    // logical screen size\n    WriteShort(width);\n    WriteShort(height);\n    // packed fields\n    out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\n          0x70 | // 2-4 : color resolution = 7\n          0x00 | // 5 : gct sort flag = 0\n          palSize)); // 6-8 : gct size\n\n    out.writeByte(0); // background color index\n    out.writeByte(0); // pixel aspect ratio - assume 1:1\n  };\n\n  /**\n   * Writes Netscape application extension to define repeat count.\n   */\n\n  var writeNetscapeExt = function writeNetscapeExt() {\n    out.writeByte(0x21); // extension introducer\n    out.writeByte(0xff); // app extension label\n    out.writeByte(11); // block size\n    out.writeUTFBytes("NETSCAPE" + "2.0"); // app id + auth code\n    out.writeByte(3); // sub-block size\n    out.writeByte(1); // loop sub-block id\n    WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\n    out.writeByte(0); // block terminator\n  };\n\n  /**\n   * Writes color table\n   */\n\n  var writePalette = function writePalette() {\n    out.writeBytes(colorTab);\n    var n = (3 * 256) - colorTab.length;\n    for (var i = 0; i < n; i++) out.writeByte(0);\n  };\n\n  var WriteShort = function WriteShort(pValue) {\n    out.writeByte(pValue & 0xFF);\n    out.writeByte((pValue >> 8) & 0xFF);\n  };\n\n  /**\n   * Encodes and writes pixel data\n   */\n\n  var writePixels = function writePixels() {\n    var myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\n    myencoder.encode(out);\n  };\n\n  /**\n   * Retrieves the GIF stream\n   */\n\n  var stream = exports.stream = function stream() {\n    return out;\n  };\n\n  var setProperties = exports.setProperties = function setProperties(has_start, is_first) {\n    started = has_start;\n    firstFrame = is_first;\n  };\n\n  return exports;\n\n};\n\nmodule.exports = GIFEncoder;\n\n\n//# sourceURL=webpack:///./node_modules/readwrite-gif/src/GIFEncoder.js?')},227:function(module,exports){eval("/**\n * This class handles LZW encoding\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nvar LZWEncoder = function() {\n\n  var exports = {};\n  var EOF = -1;\n  var imgW;\n  var imgH;\n  var pixAry;\n  var initCodeSize;\n  var remaining;\n  var curPixel;\n\n  // GIFCOMPR.C - GIF Image compression routines\n  // Lempel-Ziv compression based on 'compress'. GIF modifications by\n  // David Rowley (mgardi@watdcsu.waterloo.edu)\n  // General DEFINEs\n\n  var BITS = 12;\n  var HSIZE = 5003; // 80% occupancy\n\n  // GIF Image compression - modified 'compress'\n  // Based on: compress.c - File compression ala IEEE Computer, June 1984.\n  // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n  // Jim McKie (decvax!mcvax!jim)\n  // Steve Davies (decvax!vax135!petsd!peora!srd)\n  // Ken Turkowski (decvax!decwrl!turtlevax!ken)\n  // James A. Woods (decvax!ihnp4!ames!jaw)\n  // Joe Orost (decvax!vax135!petsd!joe)\n\n  var n_bits; // number of bits/code\n  var maxbits = BITS; // user settable max # bits/code\n  var maxcode; // maximum code, given n_bits\n  var maxmaxcode = 1 << BITS; // should NEVER generate this code\n  var htab = [];\n  var codetab = [];\n  var hsize = HSIZE; // for dynamic table sizing\n  var free_ent = 0; // first unused entry\n\n  // block compression parameters -- after all codes are used up,\n  // and compression rate changes, start over.\n\n  var clear_flg = false;\n\n  // Algorithm: use open addressing double hashing (no chaining) on the\n  // prefix code / next character combination. We do a variant of Knuth's\n  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n  // secondary probe. Here, the modular division first probe is gives way\n  // to a faster exclusive-or manipulation. Also do block compression with\n  // an adaptive reset, whereby the code table is cleared when the compression\n  // ratio decreases, but after the table fills. The variable-length output\n  // codes are re-sized at this point, and a special CLEAR code is generated\n  // for the decompressor. Late addition: construct the table according to\n  // file size for noticeable speed improvement on small files. Please direct\n  // questions about this implementation to ames!jaw.\n\n  var g_init_bits;\n  var ClearCode;\n  var EOFCode;\n\n  // output\n  // Output the given code.\n  // Inputs:\n  // code: A n_bits-bit integer. If == -1, then EOF. This assumes\n  // that n_bits =< wordsize - 1.\n  // Outputs:\n  // Outputs code to the file.\n  // Assumptions:\n  // Chars are 8 bits long.\n  // Algorithm:\n  // Maintain a BITS character long buffer (so that 8 codes will\n  // fit in it exactly). Use the VAX insv instruction to insert each\n  // code in turn. When the buffer fills up empty it and start over.\n\n  var cur_accum = 0;\n  var cur_bits = 0;\n  var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\n\n  // Number of characters so far in this 'packet'\n  var a_count;\n\n  // Define the storage for the packet accumulator\n  var accum = [];\n\n  var LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\n    imgW = width;\n    imgH = height;\n    pixAry = pixels;\n    initCodeSize = Math.max(2, color_depth);\n  };\n\n  // Add a character to the end of the current packet, and if it is 254\n  // characters, flush the packet to disk.\n  var char_out = function char_out(c, outs) {\n    accum[a_count++] = c;\n    if (a_count >= 254) flush_char(outs);\n  };\n\n  // Clear out the hash table\n  // table clear for block compress\n\n  var cl_block = function cl_block(outs) {\n    cl_hash(hsize);\n    free_ent = ClearCode + 2;\n    clear_flg = true;\n    output(ClearCode, outs);\n  };\n\n  // reset code table\n  var cl_hash = function cl_hash(hsize) {\n    for (var i = 0; i < hsize; ++i) htab[i] = -1;\n  };\n\n  var compress = exports.compress = function compress(init_bits, outs) {\n\n    var fcode;\n    var i; /* = 0 */\n    var c;\n    var ent;\n    var disp;\n    var hsize_reg;\n    var hshift;\n\n    // Set up the globals: g_init_bits - initial number of bits\n    g_init_bits = init_bits;\n\n    // Set up the necessary values\n    clear_flg = false;\n    n_bits = g_init_bits;\n    maxcode = MAXCODE(n_bits);\n\n    ClearCode = 1 << (init_bits - 1);\n    EOFCode = ClearCode + 1;\n    free_ent = ClearCode + 2;\n\n    a_count = 0; // clear packet\n\n    ent = nextPixel();\n\n    hshift = 0;\n    for (fcode = hsize; fcode < 65536; fcode *= 2)\n      ++hshift;\n    hshift = 8 - hshift; // set hash code range bound\n\n    hsize_reg = hsize;\n    cl_hash(hsize_reg); // clear hash table\n\n    output(ClearCode, outs);\n\n    outer_loop: while ((c = nextPixel()) != EOF) {\n      fcode = (c << maxbits) + ent;\n      i = (c << hshift) ^ ent; // xor hashing\n\n      if (htab[i] == fcode) {\n        ent = codetab[i];\n        continue;\n      }\n\n      else if (htab[i] >= 0) { // non-empty slot\n\n        disp = hsize_reg - i; // secondary hash (after G. Knott)\n        if (i === 0) disp = 1;\n\n        do {\n          if ((i -= disp) < 0)\n            i += hsize_reg;\n\n          if (htab[i] == fcode) {\n            ent = codetab[i];\n            continue outer_loop;\n          }\n        } while (htab[i] >= 0);\n      }\n\n      output(ent, outs);\n      ent = c;\n      if (free_ent < maxmaxcode) {\n        codetab[i] = free_ent++; // code -> hashtable\n        htab[i] = fcode;\n      }\n      else cl_block(outs);\n    }\n\n                // Put out the final code.\n                output(ent, outs);\n                output(EOFCode, outs);\n  };\n\n  // ----------------------------------------------------------------------------\n  var encode = exports.encode = function encode(os) {\n    os.writeByte(initCodeSize); // write \"initial code size\" byte\n    remaining = imgW * imgH; // reset navigation variables\n    curPixel = 0;\n    compress(initCodeSize + 1, os); // compress and write the pixel data\n    os.writeByte(0); // write block terminator\n  };\n\n  // Flush the packet to disk, and reset the accumulator\n  var flush_char = function flush_char(outs) {\n    if (a_count > 0) {\n      outs.writeByte(a_count);\n      outs.writeBytes(accum, 0, a_count);\n      a_count = 0;\n    }\n  };\n\n  var MAXCODE = function MAXCODE(n_bits) {\n    return (1 << n_bits) - 1;\n  };\n\n  // ----------------------------------------------------------------------------\n  // Return the next pixel from the image\n  // ----------------------------------------------------------------------------\n\n  var nextPixel = function nextPixel() {\n    if (remaining === 0) return EOF;\n    --remaining;\n    var pix = pixAry[curPixel++];\n    return pix & 0xff;\n  };\n\n  var output = function output(code, outs) {\n\n    cur_accum &= masks[cur_bits];\n\n    if (cur_bits > 0) cur_accum |= (code << cur_bits);\n    else cur_accum = code;\n\n    cur_bits += n_bits;\n\n    while (cur_bits >= 8) {\n      char_out((cur_accum & 0xff), outs);\n      cur_accum >>= 8;\n      cur_bits -= 8;\n    }\n\n    // If the next entry is going to be too big for the code size,\n    // then increase it, if possible.\n\n    if (free_ent > maxcode || clear_flg) {\n\n      if (clear_flg) {\n\n        maxcode = MAXCODE(n_bits = g_init_bits);\n        clear_flg = false;\n\n      } else {\n\n        ++n_bits;\n        if (n_bits == maxbits) maxcode = maxmaxcode;\n        else maxcode = MAXCODE(n_bits);\n      }\n    }\n\n    if (code == EOFCode) {\n\n      // At EOF, write the rest of the buffer.\n      while (cur_bits > 0) {\n        char_out((cur_accum & 0xff), outs);\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n\n      flush_char(outs);\n    }\n  };\n\n  LZWEncoder.apply(this, arguments);\n  return exports;\n};\n\nmodule.exports = LZWEncoder;\n\n\n//# sourceURL=webpack:///./node_modules/readwrite-gif/src/LZWEncoder.js?")},228:function(module,exports){eval('/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * "Kohonen neural networks for optimal colour quantization" in "Network:\n * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the "Software"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/*\n * This class handles Neural-Net quantization algorithm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nvar NeuQuant = function() {\n\n  var exports = {};\n  var netsize = 256; /* number of colours used */\n\n  /* four primes near 500 - assume no image has a length so large */\n  /* that it is divisible by all four primes */\n\n  var prime1 = 499;\n  var prime2 = 491;\n  var prime3 = 487;\n  var prime4 = 503;\n  var minpicturebytes = (3 * prime4); /* minimum size for input image */\n\n  /*\n   * Program Skeleton ---------------- [select samplefac in range 1..30] [read\n   * image from input file] pic = (unsigned char*) malloc(3*width*height);\n   * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\n   * image header, using writecolourmap(f)] inxbuild(); write output image using\n   * inxsearch(b,g,r)\n   */\n\n  /*\n   * Network Definitions -------------------\n   */\n\n  var maxnetpos = (netsize - 1);\n  var netbiasshift = 4; /* bias for colour values */\n  var ncycles = 100; /* no. of learning cycles */\n\n  /* defs for freq and bias */\n  var intbiasshift = 16; /* bias for fractions */\n  var intbias = (1 << intbiasshift);\n  var gammashift = 10; /* gamma = 1024 */\n  var gamma = (1 << gammashift);\n  var betashift = 10;\n  var beta = (intbias >> betashift); /* beta = 1/1024 */\n  var betagamma = (intbias << (gammashift - betashift));\n\n  /* defs for decreasing radius factor */\n  var initrad = (netsize >> 3); /* for 256 cols, radius starts */\n  var radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\n  var radiusbias = (1 << radiusbiasshift);\n  var initradius = (initrad * radiusbias); /* and decreases by a */\n  var radiusdec = 30; /* factor of 1/30 each cycle */\n\n  /* defs for decreasing alpha factor */\n  var alphabiasshift = 10; /* alpha starts at 1.0 */\n  var initalpha = (1 << alphabiasshift);\n  var alphadec; /* biased by 10 bits */\n\n  /* radbias and alpharadbias used for radpower calculation */\n  var radbiasshift = 8;\n  var radbias = (1 << radbiasshift);\n  var alpharadbshift = (alphabiasshift + radbiasshift);\n  var alpharadbias = (1 << alpharadbshift);\n\n  /*\n   * Types and Global Variables --------------------------\n   */\n\n  var thepicture; /* the input image itself */\n  var lengthcount; /* lengthcount = H*W*3 */\n  var samplefac; /* sampling factor 1..30 */\n\n  // typedef int pixel[4]; /* BGRc */\n  var network; /* the network itself - [netsize][4] */\n  var netindex = [];\n\n  /* for network lookup - really 256 */\n  var bias = [];\n\n  /* bias and freq arrays for learning */\n  var freq = [];\n  var radpower = [];\n\n  var NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\n\n    var i;\n    var p;\n\n    thepicture = thepic;\n    lengthcount = len;\n    samplefac = sample;\n\n    network = new Array(netsize);\n\n    for (i = 0; i < netsize; i++) {\n\n      network[i] = new Array(4);\n      p = network[i];\n      p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\n      freq[i] = intbias / netsize; /* 1/netsize */\n      bias[i] = 0;\n    }\n  };\n\n  var colorMap = function colorMap() {\n\n    var map = [];\n    var index = new Array(netsize);\n\n    for (var i = 0; i < netsize; i++)\n      index[network[i][3]] = i;\n\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = (network[j][0]);\n      map[k++] = (network[j][1]);\n      map[k++] = (network[j][2]);\n    }\n\n    return map;\n  };\n\n  /*\n   * Insertion sort of network and building of netindex[0..255] (to do after\n   * unbias)\n   * -------------------------------------------------------------------------------\n   */\n\n  var inxbuild = function inxbuild() {\n\n    var i;\n    var j;\n    var smallpos;\n    var smallval;\n    var p;\n    var q;\n    var previouscol;\n    var startpos;\n\n    previouscol = 0;\n    startpos = 0;\n    for (i = 0; i < netsize; i++) {\n\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; /* index on g */\n\n      /* find smallest in i..netsize-1 */\n      for (j = i + 1; j < netsize; j++) {\n\n        q = network[j];\n        if (q[1] < smallval) { /* index on g */\n          smallpos = j;\n          smallval = q[1]; /* index on g */\n        }\n      }\n      q = network[smallpos];\n\n      /* swap p (i) and q (smallpos) entries */\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      }\n\n      /* smallval entry is now in position i */\n\n      if (smallval != previouscol) {\n\n        netindex[previouscol] = (startpos + i) >> 1;\n\n        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\n  };\n\n  /*\n   * Main Learning Loop ------------------\n   */\n\n  var learn = function learn() {\n\n    var i;\n    var j;\n    var b;\n    var g;\n    var r;\n    var radius;\n    var rad;\n    var alpha;\n    var step;\n    var delta;\n    var samplepixels;\n    var p;\n    var pix;\n    var lim;\n\n    if (lengthcount < minpicturebytes) samplefac = 1;\n\n    alphadec = 30 + ((samplefac - 1) / 3);\n    p = thepicture;\n    pix = 0;\n    lim = lengthcount;\n    samplepixels = lengthcount / (3 * samplefac);\n    delta = (samplepixels / ncycles) | 0;\n    alpha = initalpha;\n    radius = initradius;\n\n    rad = radius >> radiusbiasshift;\n    if (rad <= 1) rad = 0;\n\n    for (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n    if (lengthcount < minpicturebytes) step = 3;\n\n    else if ((lengthcount % prime1) !== 0) step = 3 * prime1;\n\n    else {\n\n      if ((lengthcount % prime2) !== 0) step = 3 * prime2;\n      else {\n        if ((lengthcount % prime3) !== 0) step = 3 * prime3;\n        else step = 3 * prime4;\n      }\n    }\n\n    i = 0;\n    while (i < samplepixels) {\n\n      b = (p[pix + 0] & 0xff) << netbiasshift;\n      g = (p[pix + 1] & 0xff) << netbiasshift;\n      r = (p[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\n\n      pix += step;\n      if (pix >= lim) pix -= lengthcount;\n\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) rad = 0;\n\n        for (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n      }\n    }\n  };\n\n  /*\n   ** Search for BGR values 0..255 (after net is unbiased) and return colour\n   * index\n   * ----------------------------------------------------------------------------\n   */\n\n  var map = exports.map = function map(b, g, r) {\n\n    var i;\n    var j;\n    var dist;\n    var a;\n    var bestd;\n    var p;\n    var best;\n\n    bestd = 1000; /* biggest possible dist is 256*3 */\n    best = -1;\n    i = netindex[g]; /* index on g */\n    j = i - 1; /* start at netindex[g] and work outwards */\n\n    while ((i < netsize) || (j >= 0)) {\n\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; /* inx key */\n\n        if (dist >= bestd) i = netsize; /* stop iter */\n\n        else {\n\n          i++;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n\n      if (j >= 0) {\n\n        p = network[j];\n        dist = g - p[1]; /* inx key - reverse dif */\n\n        if (dist >= bestd) j = -1; /* stop iter */\n\n        else {\n\n          j--;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n\n    return (best);\n  };\n\n  var process = exports.process = function process() {\n    learn();\n    unbiasnet();\n    inxbuild();\n    return colorMap();\n  };\n\n  /*\n   * Unbias network to give byte values 0..255 and record position i to prepare\n   * for sort\n   * -----------------------------------------------------------------------------------\n   */\n\n  var unbiasnet = function unbiasnet() {\n\n    var i;\n    var j;\n\n    for (i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; /* record colour no */\n    }\n  };\n\n  /*\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\n   * radpower[|i-j|]\n   * ---------------------------------------------------------------------------------\n   */\n\n  var alterneigh = function alterneigh(rad, i, b, g, r) {\n\n    var j;\n    var k;\n    var lo;\n    var hi;\n    var a;\n    var m;\n    var p;\n\n    lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    hi = i + rad;\n    if (hi > netsize) hi = netsize;\n\n    j = i + 1;\n    k = i - 1;\n    m = 1;\n\n    while ((j < hi) || (k > lo)) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n\n        try {\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\n        } catch (e) {} // prevents 1.3 miscompilation\n      }\n\n      if (k > lo) {\n        p = network[k--];\n\n        try {\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\n        } catch (e) {}\n      }\n    }\n  };\n\n  /*\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   * ----------------------------------------------------\n   */\n\n  var altersingle = function altersingle(alpha, i, b, g, r) {\n\n    /* alter hit neuron */\n    var n = network[i];\n    n[0] -= (alpha * (n[0] - b)) / initalpha;\n    n[1] -= (alpha * (n[1] - g)) / initalpha;\n    n[2] -= (alpha * (n[2] - r)) / initalpha;\n  };\n\n  /*\n   * Search for biased BGR values ----------------------------\n   */\n\n  var contest = function contest(b, g, r) {\n\n    /* finds closest neuron (min dist) and updates freq */\n    /* finds best neuron (min dist-bias) and returns position */\n    /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\n    /* bias[i] = gamma*((1/netsize)-freq[i]) */\n\n    var i;\n    var dist;\n    var a;\n    var biasdist;\n    var betafreq;\n    var bestpos;\n    var bestbiaspos;\n    var bestd;\n    var bestbiasd;\n    var n;\n\n    bestd = ~ (1 << 31);\n    bestbiasd = bestd;\n    bestpos = -1;\n    bestbiaspos = bestpos;\n\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n      dist = n[0] - b;\n      if (dist < 0) dist = -dist;\n      a = n[1] - g;\n      if (a < 0) a = -a;\n      dist += a;\n      a = n[2] - r;\n      if (a < 0) a = -a;\n      dist += a;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = (freq[i] >> betashift);\n      freq[i] -= betafreq;\n      bias[i] += (betafreq << gammashift);\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return (bestbiaspos);\n  };\n\n  NeuQuant.apply(this, arguments);\n  return exports;\n};\n\nmodule.exports = NeuQuant;\n\n\n//# sourceURL=webpack:///./node_modules/readwrite-gif/src/NeuQuant.js?')},229:function(module,exports){eval('// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\nfunction GifReader(buf) {\n  var p = 0;\n\n  // - Header.\n  if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 ||  // GIF\n      buf[p++] !== 0x38 || buf[p++] !== 0x39 || buf[p++] !== 0x61) {  // 89a\n    throw "Invalid GIF 89a header.";\n  }\n\n  // - Logical Screen Descriptor.\n  var width = buf[p++] | buf[p++] << 8;\n  var height = buf[p++] | buf[p++] << 8;\n  var pf0 = buf[p++];  // <Packed Fields>.\n  var global_palette_flag = pf0 >> 7;\n  var num_global_colors_pow2 = pf0 & 0x7;\n  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\n  var background = buf[p++];\n  buf[p++];  // Pixel aspect ratio (unused?).\n\n  var global_palette_offset = null;\n\n  if (global_palette_flag) {\n    global_palette_offset = p;\n    p += num_global_colors * 3;  // Seek past palette.\n  }\n\n  var loop_count = null;\n\n  var no_eof = true;\n\n  var frames = [ ];\n\n  var delay = 0;\n  var transparent_index = null;\n  var disposal = 0;  // 0 - No disposal specified.\n  var loop_count = null;\n\n  this.width = width;\n  this.height = height;\n\n  while (no_eof && p < buf.length) {\n    switch (buf[p++]) {\n      case 0x21:  // Graphics Control Extension Block\n        switch (buf[p++]) {\n          case 0xff:  // Application specific block\n            // Try if it\'s a Netscape block (with animation loop counter).\n            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\n                // NETSCAPE2.0\n                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\n                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\n                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\n                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\n                // Sub-block\n                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\n              p += 14;\n              loop_count = buf[p++] | buf[p++] << 8;\n              p++;  // Skip terminator.\n            } else {  // We don\'t know what it is, just try to get past it.\n              p += 12;\n              while (true) {  // Seek through subblocks.\n                var block_size = buf[p++];\n                if (block_size === 0) break;\n                p += block_size;\n              }\n            }\n            break;\n\n          case 0xf9:  // Graphics Control Extension\n            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\n              throw "Invalid graphics extension block.";\n            var pf1 = buf[p++];\n            delay = buf[p++] | buf[p++] << 8;\n            transparent_index = buf[p++];\n            if ((pf1 & 1) === 0) transparent_index = null;\n            disposal = pf1 >> 2 & 0x7;\n            p++;  // Skip terminator.\n            break;\n\n          case 0xfe:  // Comment Extension.\n            while (true) {  // Seek through subblocks.\n              var block_size = buf[p++];\n              if (block_size === 0) break;\n              // console.log(buf.slice(p, p+block_size).toString(\'ascii\'));\n              p += block_size;\n            }\n            break;\n\n          default:\n            throw "Unknown graphic control label: 0x" + buf[p-1].toString(16);\n        }\n        break;\n\n      case 0x2c:  // Image Descriptor.\n        var x = buf[p++] | buf[p++] << 8;\n        var y = buf[p++] | buf[p++] << 8;\n        var w = buf[p++] | buf[p++] << 8;\n        var h = buf[p++] | buf[p++] << 8;\n        var pf2 = buf[p++];\n        var local_palette_flag = pf2 >> 7;\n        var interlace_flag = pf2 >> 6 & 1;\n        var num_local_colors_pow2 = pf2 & 0x7;\n        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\n        var palette_offset = global_palette_offset;\n        var has_local_palette = false;\n        if (local_palette_flag) {\n          var has_local_palette = true;\n          palette_offset = p;  // Override with local palette.\n          p += num_local_colors * 3;  // Seek past palette.\n        }\n\n        var data_offset = p;\n\n        p++;  // codesize\n        while (true) {\n          var block_size = buf[p++];\n          if (block_size === 0) break;\n          p += block_size;\n        }\n\n        frames.push({x: x, y: y, width: w, height: h,\n                     has_local_palette: has_local_palette,\n                     palette_offset: palette_offset,\n                     data_offset: data_offset,\n                     data_length: p - data_offset,\n                     transparent_index: transparent_index,\n                     interlaced: !!interlace_flag,\n                     delay: delay,\n                     disposal: disposal});\n        break;\n\n      case 0x3b:  // Trailer Marker (end of file).\n        no_eof = false;\n        break;\n\n      default:\n        throw "Unknown gif block: 0x" + buf[p-1].toString(16);\n        break;\n    }\n  }\n\n  this.numFrames = function() {\n    return frames.length;\n  };\n\n  this.frameInfo = function(frame_num) {\n    if (frame_num < 0 || frame_num >= frames.length)\n      throw "Frame index out of range.";\n    return frames[frame_num];\n  }\n\n  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it\'s related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += (framewidth + framestride) * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride =\n              framestride + (framewidth + framestride) * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = b;\n        pixels[op++] = g;\n        pixels[op++] = r;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n\n  // I will go to copy and paste hell one day...\n  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it\'s related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += (framewidth + framestride) * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride =\n              framestride + (framewidth + framestride) * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = r;\n        pixels[op++] = g;\n        pixels[op++] = b;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n}\n\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n  var min_code_size = code_stream[p++];\n\n  var clear_code = 1 << min_code_size;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  // NOTE: This shares the same name as the encoder, but has a different\n  // meaning here.  Here this masks each code coming from the code stream.\n  var code_mask = (1 << cur_code_size) - 1;\n  var cur_shift = 0;\n  var cur = 0;\n\n  var op = 0;  // Output pointer.\n  \n  var subblock_size = code_stream[p++];\n\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n  // solve the fast mode / backing store uncertainty.\n  // var code_table = Array(4096);\n  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\n\n  var prev_code = null;  // Track code-1.\n\n  while (true) {\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\n    while (cur_shift < 16) {\n      if (subblock_size === 0) break;  // No more data to be read.\n\n      cur |= code_stream[p++] << cur_shift;\n      cur_shift += 8;\n\n      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\n        subblock_size = code_stream[p++];  // Next subblock.\n      } else {\n        --subblock_size;\n      }\n    }\n\n    // TODO(deanm): We should never really get here, we should have received\n    // and EOI.\n    if (cur_shift < cur_code_size)\n      break;\n\n    var code = cur & code_mask;\n    cur >>= cur_code_size;\n    cur_shift -= cur_code_size;\n\n    // TODO(deanm): Maybe should check that the first code was a clear code,\n    // at least this is what you\'re supposed to do.  But actually our encoder\n    // now doesn\'t emit a clear code first anyway.\n    if (code === clear_code) {\n      // We don\'t actually have to clear the table.  This could be a good idea\n      // for greater error checking, but we don\'t really do any anyway.  We\n      // will just track it with next_code and overwrite old entries.\n\n      next_code = eoi_code + 1;\n      cur_code_size = min_code_size + 1;\n      code_mask = (1 << cur_code_size) - 1;\n\n      // Don\'t update prev_code ?\n      prev_code = null;\n      continue;\n    } else if (code === eoi_code) {\n      break;\n    }\n\n    // We have a similar situation as the decoder, where we want to store\n    // variable length entries (code table entries), but we want to do in a\n    // faster manner than an array of arrays.  The code below stores sort of a\n    // linked list within the code table, and then "chases" through it to\n    // construct the dictionary entries.  When a new entry is created, just the\n    // last byte is stored, and the rest (prefix) of the entry is only\n    // referenced by its table entry.  Then the code chases through the\n    // prefixes until it reaches a single byte code.  We have to chase twice,\n    // first to compute the length, and then to actually copy the data to the\n    // output (backwards, since we know the length).  The alternative would be\n    // storing something in an intermediate stack, but that doesn\'t make any\n    // more sense.  I implemented an approach where it also stored the length\n    // in the code table, although it\'s a bit tricky because you run out of\n    // bits (12 + 12 + 8), but I didn\'t measure much improvements (the table\n    // entries are generally not the long).  Even when I created benchmarks for\n    // very long table entries the complexity did not seem worth it.\n    // The code table stores the prefix entry in 12 bits and then the suffix\n    // byte in 8 bits, so each entry is 20 bits.\n\n    var chase_code = code < next_code ? code : prev_code;\n\n    // Chase what we will output, either {CODE} or {CODE-1}.\n    var chase_length = 0;\n    var chase = chase_code;\n    while (chase > clear_code) {\n      chase = code_table[chase] >> 8;\n      ++chase_length;\n    }\n\n    var k = chase;\n    \n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n    if (op_end > output_length) {\n      console.log("Warning, gif stream longer than expected.");\n      return;\n    }\n\n    // Already have the first byte from the chase, might as well write it fast.\n    output[op++] = k;\n\n    op += chase_length;\n    var b = op;  // Track pointer, writing backwards.\n\n    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\n      output[op++] = k;\n\n    chase = chase_code;\n    while (chase_length--) {\n      chase = code_table[chase];\n      output[--b] = chase & 0xff;  // Write backwards.\n      chase >>= 8;  // Pull down to the prefix code.\n    }\n\n    if (prev_code !== null && next_code < 4096) {\n      code_table[next_code++] = prev_code << 8 | k;\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n      // have an feeling that it should just happen somewhere else, for now it\n      // is awkward between when we grow past the max and then hit a clear code.\n      // For now just check if we hit the max 12-bits (then a clear code should\n      // follow, also of course encoded in 12-bits).\n      if (next_code >= code_mask+1 && cur_code_size < 12) {\n        ++cur_code_size;\n        code_mask = code_mask << 1 | 1;\n      }\n    }\n\n    prev_code = code;\n  }\n\n  if (op !== output_length) {\n    console.log("Warning, gif stream shorter than expected.");\n  }\n\n  return output;\n}\n\nmodule.exports = GifReader;\n\n\n//# sourceURL=webpack:///./node_modules/readwrite-gif/src/GifReader.js?')},232:function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Encoder = __webpack_require__(226),\n  Decoder = __webpack_require__(229);\n\nmodule.exports = {\n  Encoder: Encoder,\n  Decoder: Decoder\n};\n\n\n//# sourceURL=webpack:///./node_modules/readwrite-gif/index.js?")}}]);